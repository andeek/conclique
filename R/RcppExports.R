# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Functions for using conclique based GOF test.
#' 
#' @param data A list containing two elements, 
#'        sums and nums which contain the sum of the data in each neighborhood as well as the number of locations 
#'        in the neighborhood for each point in the conclique. 
#' @param params A list of parameter values, rho, kappa, and eta, that parameterize the Gaussian MRF.
#' @name cdf
NULL

#' @rdname cdf
#' @export
gaussian_single_param_cdf <- function(data, params) {
    .Call('_conclique_gaussian_single_param_cdf', PACKAGE = 'conclique', data, params)
}

#' Run a conclique-based Gibbs sampler to sample spatial data given a lattice and neighborhood structure.
#' 
#' @param conclique_cover A list of class "conclique_cover" encoding the locations in each conclique for 
#'        the conclique cover
#' @param neighbors A list of matrices encoding the neighbors for each point, where the first column of each matrix is the location id of each location in the lattice. This could be the result from get_neighbors().
#'                  Include multiple matrices within the list for more complicated neighborhood structures in your corresponding sampler, for example a (two) dependency parameter for N/S, E/W.
#' @param inits Initial values for the lattice, formatted as a grid.
#' @param conditional_sampler The string name of a function that has two inputs: 
#'        \itemize{
#'          \item{data, and}
#'          \item{params.}
#'        }
#'        There are three built in samplers:
#'         \itemize{
#'           \item{"gaussian_single_param" - a Gaussian sampler with a single dependence parameter,}
#'           \item{"binary_single_param" - a binary sampler with a single dependence parameter, and}
#'           \item{"binary_two_param" - a binary sampler with two dependence parameters.}
#'         }
#'        If the user chooses to write their own sampler in R, they must pass the name of the sampler that is available in the global environment as this parameter.
#'        The input "data" is a list containing at least two elements, 
#'        sums and nums which contain the sum of the data in each neighborhood as well as the number of locations 
#'        in the neighborhood for each point in the conclique. In addition, the data can contain two additional elements, u and v, 
#'        which are vectors that contain the horizontal and vertical location of each point in space.
#'        The input "params" is a list of parameter values. This function returns 
#'        a value sampled from the specified conditional distribution given the data and parameters passed.
#' @param params A list of parameters to be passed to the conditional_sampler function     
#' @param n_iter Number of times to run the Gibbs sampler
#' @export
run_conclique_gibbs <- function(conclique_cover, neighbors, inits, conditional_sampler, params, n_iter = 100L) {
    .Call('_conclique_run_conclique_gibbs', PACKAGE = 'conclique', conclique_cover, neighbors, inits, conditional_sampler, params, n_iter)
}

#' Run a sequential Gibbs sampler to sample spatial data given a lattice and neighborhood structure.
#' 
#' @param inits Initial values for the lattice, formatted as a grid.
#' @param neighbors A matrix N*N by (max // neighbors) + 1, where the first column is the location id of each location in the lattice. This could be the result from get_neighbors().
#'                  If NULL, will be calculated within the function.
#' @param conditional_sampler The string name of a function that has two inputs: 
#'        \itemize{
#'          \item{data, and}
#'          \item{params.}
#'        }
#'        There are three built in samplers:
#'         \itemize{
#'           \item{"gaussian_single_param" - a Gaussian sampler with a single dependence parameter,}
#'           \item{"binary_single_param" - a binary sampler with a single dependence parameter, and}
#'           \item{"binary_two_param" - a binary sampler with two dependence parameters.}
#'         }
#'        If the user chooses to write their own sampler in R, they must pass the name of the sampler that is available in the gloabl environment as this parameter.
#'        The input "data" is a list containing two elements, 
#'        sums and nums which contain the sum of the data in each neighborhood as well as the number of locations 
#'        in the neighborhood for each point in the conclique. The input "params" is a list of parameter values. This function returns 
#'        a value sampled from the specified conditional distribution given the data and parameters passed.
#' @param params A list of parameters to be passed to the conditional_sampler function 
#' @param n_iter Number of times to run the Gibbs sampler
#' @export
run_sequential_gibbs <- function(neighbors, inits, conditional_sampler, params, n_iter = 100L) {
    .Call('_conclique_run_sequential_gibbs', PACKAGE = 'conclique', neighbors, inits, conditional_sampler, params, n_iter)
}

#' Functions for sampling from conditional distributions.
#' 
#' @param data A list containing two elements, 
#'        sums and nums which contain the sum of the data in each neighborhood as well as the number of locations 
#'        in the neighborhood for each point in the conclique. 
#' @param params A list of parameter values, rho, kappa, and eta, that parameterize the Gaussian MRF.
#' @name sampler
NULL

#' @rdname sampler
#' @export
gaussian_single_param_sampler <- function(data, params) {
    .Call('_conclique_gaussian_single_param_sampler', PACKAGE = 'conclique', data, params)
}

#' @rdname sampler
#' @export
binary_single_param_sampler <- function(data, params) {
    .Call('_conclique_binary_single_param_sampler', PACKAGE = 'conclique', data, params)
}

#' @rdname sampler
#' @export
binary_two_param_sampler <- function(data, params) {
    .Call('_conclique_binary_two_param_sampler', PACKAGE = 'conclique', data, params)
}

#' Get spatial residuals from data given a neighborhood structure and MRF model.
#' 
#' @param data A vector containing data values for each location in the lattice.
#' @param neighbors A matrix N*N by (max # neighbors) + 1, where the first column is the location id of each location in the lattice. This could be the result from get_neighbors().
#' @param conditional_cdf A function that has two inputs: 
#'        \itemize{
#'          \item{data, and}
#'          \item{params.}
#'        }
#'        There are three built in cdfs:
#'         \itemize{
#'           \item{"gaussian_single_param" - a Gaussian cdf with a single dependence parameter,}
#'           \item{"binary_single_param" - a binary cdf with a single dependence parameter, and}
#'           \item{"binary_two_param" - a binary cdf with two dependence parameters.}
#'         }
#'        If the user chooses to write their own cdf in R, they must pass the name of the cdf function that is available in the global environment as this parameter.
#'        The input "data" is a list containing at least two elements, 
#'        sums and nums which contain the sum of the data in each neighborhood as well as the number of locations 
#'        in the neighborhood for each point in the conclique. In addition, the data can contain two additional elements, u and v, 
#'        which are vectors that contain the horizontal and vertical location of each point in space.
#'        The input "params" is a list of parameter values. This function returns the inverse cdf at a value between 0 and 1 from the conditional distribution
#' @param params A list of parameters to be passed to the conditional_density function 
#' @param discrete If you are dealing with a discrete distribution, the string name of the pmf function. Otherwise, leave as an empty string.
#' @param ncols A integer of the number of columns in the original grid. Only necessary if dealing with "u" and "v" in cdf function.
#' @export
spatial_residuals <- function(data, neighbors, conditional_cdf, params, discrete = "", ncols = 0L) {
    .Call('_conclique_spatial_residuals', PACKAGE = 'conclique', data, neighbors, conditional_cdf, params, discrete, ncols)
}

